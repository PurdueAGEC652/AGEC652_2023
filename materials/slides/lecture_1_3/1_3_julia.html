<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>AGEC 652 - Lecture 1.3</title>
    <meta charset="utf-8" />
    <meta name="author" content="Diego S. Cardoso" />
    <script src="1_3_julia_files/header-attrs-2.19/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# AGEC 652 - Lecture 1.3
]
.subtitle[
## An introduction to Julia
]
.author[
### Diego S. Cardoso
]
.date[
### Spring 2023
]

---

exclude: true

```r
if (!require("pacman")) install.packages("pacman")
```

```
## Loading required package: pacman
```

```r
pacman::p_load(
  xaringanthemer, JuliaCall
)

#options(htmltools.dir.version = FALSE)

knitr::opts_hooks$set(fig.callout = function(options) {
  if (options$fig.callout) {
    options$echo &lt;- FALSE
  }

  knitr::opts_chunk$set(echo = TRUE, fig.align="center")
  options
})
```




```julia
using Pkg
Pkg.activate(".")
Pkg.instantiate()
Pkg.add("BenchmarkTools")
```



---

## Software requirements

By now you hopefully have installed
- Julia

- Visual Studio Code with Julia extension

---

class: inverse, center, middle

# Programming with Julia

.footnote[\*These slides are based on Software Carpentry, notes by Ivan Rudik and Grant Mcdermott, QuantEcon, and Julia documentation.]

---

## Why learn Julia?

**Reason 1: It is easy to learn and use**

Julia is a *high-level* language
- Low-level = you write instructions are closer to what the hardware understands (Assembly, C++, Fortran)
  - .small[E.g.: ]
  - .small[These are usually the fastest because there is little to translate (what a compiler does) and you can optimize your code depending on your hardware]
- High-level means you write in closer to human language (Julia, R, Python)
  - .small[The compiler has to do a lot more work to translate your instructions]

---

## Why learn Julia?

**Reason 2: Julia delivers C++ and Fortran speed**

.small[Sounds like magic, but it's just a clever combination of design choices targeting numerical methods]

&lt;div align="center"&gt;
  &lt;img src="figures/julia_speed_2.png" height=300&gt;
&lt;/div&gt;

.center[.footnote[*In this graph, time to execute in C++ is 1]]

---

## Why learn Julia?

**Reason 3: Julia is free, open-source, and popular**

- You don't need expensive licenses to use (unlike Matlab)

- The people who want to use or verify what you did also don't have to pay

- There is a large and active community of users and developers
  - So it's easy to get help and new packages


---

## Tools for programming in Julia

There are 2 *Integrated Development Environments (IDEs)* I generally recommend

1. Visual Studio (VS) code
2. Jupyter Lab notebooks

.blue[Please watch the "IDE showcase" video on Brightspace for an intro]

--

In this course, we will only program plain `.jl` files, so I highly recommend you get familiarized with VS code

--

- At the end of this unit, we will talk about using AI tools to help you learn to code and become a more productive programmer
  - BUT **PLEASE PLEASE**, DON'T USE AI TOOLS YET

---


## Intro to programming

### Programming `\(\equiv\)` writing a set of instructions

- There are hard rules you can't break if you want your code to work

--

- There are elements of style (e.g. Strunk and White) that make your code easier to read, modify, and maintain

--

- There are elements that make your code more efficient
  - Using less time or space (memory)


---

## Intro to programming

If you will be doing computational work, there are:

1. Language-independent coding basics you should know
    - Arrays are stored in memory in particular ways
    
2. Language-independent best practices you should use
    - Indent to convey program structure, naming conventions
    
3. Language-dependent idiosyncracies that matter for function, speed, etc
    - Julia: type stability; R: vectorize

---

## Intro to programming

Learning these early will:

1. Make coding a lot easier
--

2. Reduce total programmer time
--

3. Reduce total computer time
--

4. Make your code understandable by someone else or your future self
--

5. Make your code flexible

---

## A broad view of programming

Your goal is to make a **program**

A program is made of different components and sub-components

--

The most basic component is a **statement**, more commonly called a **line of code**


---

## A broad view of programming

Here is an example of a pseudoprogram:

```julia
*deck = ["4 of hearts", "King of clubs", "Ace of spades"]
shuffled_deck = shuffle(deck)
first_card = shuffled_deck[1]
println("The first drawn card was " * shuffled_deck ".")
```

This program is very simple:

1. Create a deck of cards

---

## A broad view of programming

Here is an example of a pseudoprogram:

```julia
deck = ["4 of hearts", "King of clubs", "Ace of spades"]
*shuffled_deck = shuffle(deck)
first_card = shuffled_deck[1]
println("The first drawn card was " * shuffled_deck ".")
```

This program is very simple:
1. Create a deck of cards
2. Shuffle the deck

---

## A broad view of programming

Here is an example of a pseudoprogram:

```julia
deck = ["4 of hearts", "King of clubs", "Ace of spades"]
shuffled_deck = shuffle(deck)
*first_card = shuffled_deck[1]
println("The first drawn card was " * shuffled_deck ".")
```

This program is very simple:
1. Create a deck of cards
2. Shuffle the deck
3. Draw the top card

---

## A broad view of programming

Here is an example of a pseudoprogram:

```julia
deck = ["4 of hearts", "King of clubs", "Ace of spades"]
shuffled_deck = shuffle(deck)
first_card = shuffled_deck[1]
*println("The first drawn card was " * shuffled_deck ".")
```

This program is very simple:
1. Create a deck of cards
2. Shuffle the deck
3. Draw the top card
4. Print it

---

## A broad view of programming

```julia
deck = ["4 of hearts", "King of clubs", "Ace of spades"]
shuffled_deck = shuffle(deck)
first_card = shuffled_deck[1]
println("The first drawn card was " * shuffled_deck ".")
```

What are the parentheses and why are they different from square brackets?

How does shuffle work?

What’s `println`?

It’s important to know that a **good program has understandable code**

---

## Julia specifics

We will discuss coding in the context of Julia
but a lot of this ports to Python, MATLAB, etc&lt;sup&gt;1&lt;/sup&gt;

We will review

1. Types
2. Iterating
3. Broadcasting/vectorization
4. Scope
5. Generic functions
6. Multiple dispatch


.footnote[&lt;sup&gt;1&lt;/sup&gt;See [https://cheatsheets.quantecon.org](https://cheatsheets.quantecon.org)]

---

class: inverse, center, middle

# 1. Types

---

## Types: boolean

All languages have some kind of **variable types** like *integers* or *arrays*

--

The first type you will often use is a boolean (`Bool`) variable that takes on a value of `true` or `false`:

```julia
x = true
```

```
## true
```

```julia
typeof(x)
```

```
## Bool
```

---

## Types: boolean

We can save the boolean value of actual statements in variables this way:

```julia
@show y = 1 &gt; 2
```

```
## y = 1 &gt; 2 = false
```

```
## false
```

`@show` is a Julia macro for showing the operation. 
- .small[You can think of a macro as a shortcut name that calls a bunch of other things to run]

---

## Quick detour: logical operators

Logical operators work like you'd think

`==` (equal equal) tests for equality


```julia
1 == 1
```

```
## true
```

--

`!=` (exclaimation point equal) tests for inequality


```julia
2 != 2
```

```
## false
```

---

## Quick detour: logical operators


You can also test for approximate equality with `\(\approx\)` (type `\approx&lt;TAB&gt;`)



```julia
1.00000001 ≈ 1
```

```
## true
```

--

Now back to types

---

## Types: numbers

Two other data types you will use frequently are integers

```julia
typeof(1)
```

```
## Int64
```

--

and floating point numbers

```julia
typeof(1.0)
```

```
## Float64
```

- .small[64 means 64 bits of storage for the number, which is probably the default on your machine]

---

## Types: numbers

You can always instantiate alternative floating point number types


```julia
converted_int = convert(Float32, 1.0);
typeof(converted_int)
```

```
## Float32
```

---

## Types: numbers

### Math works like you would expect:

```julia
a = 2
```

```
## 2
```

```julia
b = 1.0
```

```
## 1.0
```

```julia
a * b
```

```
## 2.0
```

--


```julia
a^2
```

```
## 4
```

---

## Types: numbers


```julia
2a - 4b
```

```
## 0.0
```

--


```julia
@show 4a + 3b^2
```

```
## 4a + 3 * b ^ 2 = 11.0
```

```
## 11.0
```

--

.blue[In Julia, you dont need `*` in between numeric literals (numbers) and variables]

---

## Types: strings

Strings store sequences of characters

You implement them with double quotations:


```julia
x = "Hello World!";
typeof(x)
```

```
## String
```

--

.blue[Note that `;` is used to suppress output for that line of code. Unlike some other languages, in Julia you don't need to add `;` after every command]

---

## Types: strings

It's easy to work with strings. Use `$` to interpolate a variable/expression

```julia
x = 10; y = 20; println("x + y =  $(x+y).")
```

```
## x + y =  30.
```

--

Use `*` to concatenate strings

```julia
a = "Aww"; b = "Yeah!!!"; println(a * " " * b)
```

```
## Aww Yeah!!!
```

--

You probably won't use strings too often unless you're working with text data or printing output. 
--
.blue[Note that `;` can also be used to type multiple commands in the same line. I'm doing it make it fit in this slide, but you should avoid it]


---

## Types: containers

Containers are types that store collections of data

--

The most basic container is the `Array` which is denoted by square brackets

--



```julia
a1 = [1 2; 3 4]; typeof(a1)
```

```
## Matrix{Int64} (alias for Array{Int64, 2})
```

--

Arrays are **mutable**, which means you can change their values

--


```julia
a1[1,1] = 5; a1
```

```
## 2×2 Matrix{Int64}:
##  5  2
##  3  4
```

You reference elements in a container with square brackets

---

## Types: containers

An alternative to the `Array` is the `Tuple`, which is denoted by parentheses

--


```julia
a2 = (1, 2, 3, 4); typeof(a2)
```

```
## NTuple{4, Int64}
```
`a2` is a `Tuple` of 4 `Int64`s. Tuples have no dimension

---

## Types: containers

Tuples are **immutable** which means you **can't** change their values

```julia
try
  a2[1,1] = 5;
catch
  println("Error, can't change value of a tuple.")
end
```

```
## Error, can't change value of a tuple.
```

---

## Types: containers

Tuples don't need parentheses (but it's probably best practice for clarity)

```julia
a3 = 5, 6; typeof(a3)
```

```
## Tuple{Int64, Int64}
```

---

## Types: containers

Tuples can be **unpacked** 

--


```julia
a3_x, a3_y = a3;
a3_x
```

```
## 5
```

```julia
a3_y
```

```
## 6
```

--

This is basically how functions return output when you call them

---

## Types: containers

But an alternative and more efficient container is the  [`NamedTuple`](https://docs.julialang.org/en/v1/manual/types/#Named-Tuple-Types-1) 


```julia
nt = (x = 10, y = 11); typeof(nt)
```

```
## NamedTuple{(:x, :y), Tuple{Int64, Int64}}
```

```julia
nt.x
```

```
## 10
```

```julia
nt.y
```

```
## 11
```

Another way of accessing `x` and `y` inside the NamedTuple is


```julia
nt[:x]; nt[:y];
```


---

## Types: containers

A `Dictionary` is the last main container type. They are like arrays but are indexed by keys (names) instead of numbers

--


```julia
d1 = Dict("class" =&gt; "AAAA999", "grade" =&gt; 97);
typeof(d1)
```

```
## Dict{String, Any}
```

--

`d1` is a dictionary where the key are strings and the values are any kind of type

---

## Types: containers

Reference specific values you want in the dictionary by referencing the key

--


```julia
d1["class"]
```

```
## "AAAA999"
```

```julia
d1["grade"]
```

```
## 97
```

---

## Types: containers

If you just want all the keys or all the values, you can use these base functions


```julia
keys_d1 = keys(d1)
```

```
## KeySet for a Dict{String, Any} with 2 entries. Keys:
##   "class"
##   "grade"
```

```julia
values_d1 = values(d1)
```

```
## ValueIterator for a Dict{String, Any} with 2 entries. Values:
##   "AAAA999"
##   97
```

---

class: inverse, center, middle

# 2. Iteration

---

## Iterating

As in other languages we have loops at our disposal:

`for` loops iterate over containers

```julia
for count in 1:10
  random_number = rand()
  if random_number &gt; 0.2
    println("We drew a $random_number.")
  end
end
```

```
## We drew a 0.3051440648946766.
## We drew a 0.3755325686706519.
## We drew a 0.6599432681508847.
## We drew a 0.889831487594108.
## We drew a 0.6624748667537476.
## We drew a 0.9278301736599686.
## We drew a 0.4832829478112871.
## We drew a 0.7745843391384788.
```

---

## Iterating

`while` loops iterate until a logical expression is false

```julia
while rand() &gt; 0.5
  random_number = rand()
  if random_number &gt; 0.2
    println("We drew a $random_number.")
  end
end
```

---

## Iterating

An `Iterable` is something you can loop over, like arrays

--


```julia
actions = ["codes well", "skips class"];
for action in actions
    println("Charlie $action")
end
```

```
## Charlie codes well
## Charlie skips class
```

---

## Iterating

The type `Iterator` is a particularly convenient subset of Iterables

--

These include things like the dictionary keys:

```julia
for key in keys(d1)
  println(d1[key])
end
```

```
## AAAA999
## 97
```

---

## Iterating

Iterating on `Iterator`s is more *memory efficient* than iterating on arrays

--

Here's a **very** simple example. The top function iterates on an `Array`, the bottom function iterates on an `Iterator`:

--


```julia
function show_array_speed()
  m = 1
  for i = [1, 2, 3, 4, 5, 6]
    m = m*i
  end
end;

function show_iterator_speed()
  m = 1
  for i = 1:6
    m = m*i
  end
end;
```

---

## Iterating



```julia
using BenchmarkTools
@btime show_array_speed()
```

```
##   29.074 ns (1 allocation: 112 bytes)
```

```julia
@btime show_iterator_speed()
```

```
##   2.000 ns (0 allocations: 0 bytes)
```

The `Iterator` approach is faster and allocates no memory

`@btime` is a macro from `BenchmarkTools` that shows you the elasped time and memory allocation

---

## Neat looping

A nice thing about Julia vs MATLAB: your loops can be much neater because you don't need to index when you just want the container elements

--


```julia
f(x) = x^2;
x_values = 0:20:100;
for x in x_values
  println(f(x))
end
```

```
## 0
## 400
## 1600
## 3600
## 6400
## 10000
```

---

## Neat looping

This loop directly assigns the elements of `x_values` to `x` instead of having to do something clumsy like `x_values[i]`

--

`0:20:100` creates something called a `StepRange` (a type of `Iterator`) which starts at `0`, steps up by `20` and ends at `100`


---

## Neat looping

You can also pull out an index and the element value by enumerating


```julia
f(x) = x^2;
x_values = 0:20:100;
for (index, x) in enumerate(x_values)
  println("f(x) at value $index is $(f(x)).")
end
```

```
## f(x) at value 1 is 0.
## f(x) at value 2 is 400.
## f(x) at value 3 is 1600.
## f(x) at value 4 is 3600.
## f(x) at value 5 is 6400.
## f(x) at value 6 is 10000.
```

`enumerate` basically assigns an index vector

---

## Neat looping

There is also a lot of Python-esque functionality to loop without indexes

For example: `zip` lets you loop over multiple different iterables at once

--


```julia
last_name = ("Lincoln", "Bond", "Walras");
first_name = ("Abraham", "James", "Leon");

for (first_idx, last_idx) in zip(first_name, last_name)
  println("The name's $last_idx, $first_idx $last_idx.")
end
```

```
## The name's Lincoln, Abraham Lincoln.
## The name's Bond, James Bond.
## The name's Walras, Leon Walras.
```

---

## Neat looping

Nested loops can also be made very neatly

--


```julia
for x in 1:3, y in 3:-1:1
  println("$x minus $y is $(x-y)")
end
```

```
## 1 minus 3 is -2
## 1 minus 2 is -1
## 1 minus 1 is 0
## 2 minus 3 is -1
## 2 minus 2 is 0
## 2 minus 1 is 1
## 3 minus 3 is 0
## 3 minus 2 is 1
## 3 minus 1 is 2
```

--

The first loop is the *outer* loop, the second loop is the *inner* loop

---

## Comprehensions: the neatest looping

Comprehensions are an elegant way to use iterables that makes your code cleaner and more compact

--


```julia
squared = [y^2 for y in 1:2:11]
```

```
## 6-element Vector{Int64}:
##    1
##    9
##   25
##   49
##   81
##  121
```

This created a 1-dimension `Array` using one line

---

## Comprehensions: the neatest looping

We can also use nested loops for comprehensions

--


```julia
squared_2 = [(y+z)^2 for y in 1:2:11, z in 1:6]
```

```
## 6×6 Matrix{Int64}:
##    4    9   16   25   36   49
##   16   25   36   49   64   81
##   36   49   64   81  100  121
##   64   81  100  121  144  169
##  100  121  144  169  196  225
##  144  169  196  225  256  289
```

This created a 2-dimensional `Array`

--

Use this (and the compact nested loop) sparingly since it's hard to follow

---

class: inverse, center, middle

# 3. Broadcating/Vectorization

---

## Vectorization

Iterated operations element by element is usually an inefficient approach

Another way is to do operations over an entire array. This is called **vectorization**

&lt;div style="float: right"&gt;
  &lt;img src="figures/vectorization.png" height=250&gt;
&lt;/div&gt;

- .small[It's faster because your processor can do some operations over multiple values with one instruction]
- .small[We'll get a better idea next lecture when we review the basics of computer architecture]


---

## Dot syntax: broadcasting/vectorization

Vectorizing operations is easy in Julia: just use *dot syntax* (like in MATLAB)

--


```julia
g(x) = x^2;
squared_2 = g.(1:2:11)
```

```
## 6-element Vector{Int64}:
##    1
##    9
##   25
##   49
##   81
##  121
```

--

This is actually called **broadcasting** in Julia


---

## Dot syntax: broadcasting/vectorization

When broadcasting, you might want to consider **pre-allocating** arrays

Vectorization creates *temporary allocations*: temporary arrays in the middle of the process that aren't actually needed for the final product

Julia can do broadcasting in a nicer, faster way by .hi-blue[fusing] operations together and avoiding these temporary allocations

---

## Dot syntax: broadcasting/vectorization

Let's write two functions that do the same thing:


```julia
function show_vec_speed(x)
  out = [3x.^2 + 4x + 7x.^3 for i = 1:1]
end
function show_fuse_speed(x)
  out = @. [3x.^2 + 4x + 7x.^3 for i = 1:1]
end
```

- The top one is just a normal, non-vectorized call
- The `@.` in the bottom one vectorizes everything in one swoop: the function call, the operation, and the assignment to a variable

---

## Dot syntax: broadcasting/vectorization

First, precompile&lt;sup&gt;.blue[\*]&lt;/sup&gt; the functions


```julia
x = rand(10^6);
show_vec_speed(x);
show_fuse_speed(x);
```

.footnote[.blue[\* *Just-in-time compilation* (JIT) is one of the tricks Julia does to make things run faster.] It translates your code to processor language the first time you run it and uses the translated version every time you call it again. Here, we run the functions once so that compiling doesn't add to our measure of running time in the next slide.]

---

## Dot syntax: broadcasting/vectorization

Then, let's run and time it


```julia
@btime show_vec_speed(x)
```

```
##   11.316 ms (13 allocations: 45.78 MiB)
```

```
## 1-element Vector{Vector{Float64}}:
##  [5.212287711539079, 1.614258680979726, 3.0397345775988964, 1.8379911785502183, 5.1224153813768, 8.976973622584921, 13.781929698296521, 7.992766596018239, 0.9543116449439536, 5.454112887321924  …  3.112835980508382, 0.24917500000928, 5.71344746280003, 0.5811920233801616, 1.5843518686136615, 6.651455504745385, 0.3740494263230268, 4.5101210130502025, 10.879270664902432, 1.2463020211424607]
```

```julia
@btime show_fuse_speed(x)
```

```
##   1.680 ms (3 allocations: 7.63 MiB)
```

```
## 1-element Vector{Vector{Float64}}:
##  [5.212287711539079, 1.614258680979726, 3.0397345775988964, 1.8379911785502183, 5.1224153813768, 8.976973622584921, 13.781929698296521, 7.992766596018239, 0.9543116449439536, 5.454112887321924  …  3.112835980508382, 0.24917500000928, 5.71344746280003, 0.5811920233801616, 1.5843518686136615, 6.651455504745385, 0.3740494263230268, 4.5101210130502025, 10.879270664902432, 1.2463020211424607]
```

Full vectorization using `@.` is about 5--10x faster with 1/6 of the memory allocation

---

## Dot syntax: broadcasting/vectorization

Let's see another example


```julia
h(y,z) = y^2 + sin(z); # function to evaluate
y = 1:2:1e6+1;         # input y
z = rand(length(y));   # input z
```

---

## Dot syntax: broadcasting/vectorization

Here we are vectorizing the *function call* only


```julia
# precompile h 
h_out_1 = h.(y,z);
```


```julia
@btime h_out_1 = h.(y,z) # evaluate h.(y,z) and measure time
```

```
##   3.733 ms (4 allocations: 3.81 MiB)
```

```
## 500001-element Vector{Float64}:
##    1.3903370500203356
##    9.536342458530823
##   25.667478088480703
##   49.654584542565374
##   81.7877870345006
##  121.39710426487191
##  169.71816891673856
##  225.52456481136363
##  289.81268449817225
##  361.78144542821906
##    ⋮
##    9.999700002251146e11
##    9.999740001693208e11
##    9.999780001218231e11
##    9.999820000810587e11
##    9.999860000495486e11
##    9.999900000250323e11
##    9.99994000009319e11
##    9.999980000017374e11
##    1.0000020000011713e12
```

---
## Dot syntax: broadcasting/vectorization

Here we are vectorizing the *function call* **and** *assignment*. With pre-allocated memory and vectorized assignment, we get an additional performance gain


```julia
h_out_2 = similar(h_out_1) # This pre-allocates memory for an object of the same type and size
```


```julia
@btime h_out_2 .= h.(y,z)
```

```
##   6.820 ms (2 allocations: 128 bytes)
```

```
## 500001-element Vector{Float64}:
##    1.3903370500203356
##    9.536342458530823
##   25.667478088480703
##   49.654584542565374
##   81.7877870345006
##  121.39710426487191
##  169.71816891673856
##  225.52456481136363
##  289.81268449817225
##  361.78144542821906
##    ⋮
##    9.999700002251146e11
##    9.999740001693208e11
##    9.999780001218231e11
##    9.999820000810587e11
##    9.999860000495486e11
##    9.999900000250323e11
##    9.99994000009319e11
##    9.999980000017374e11
##    1.0000020000011713e12
```

---
## Dot syntax: broadcasting/vectorization

Here we are again vectorizing the *function call* **and** *assignment*. But the `@.` syntax helps us write clear code because we only need to use it once instead of adding `.`'s everywhere



```julia
h_out_3 = similar(h_out_1)
```

```julia
@btime @. h_out_3 = h(y,z)
```

```
##   6.561 ms (2 allocations: 128 bytes)
```

```
## 500001-element Vector{Float64}:
##    1.3903370500203356
##    9.536342458530823
##   25.667478088480703
##   49.654584542565374
##   81.7877870345006
##  121.39710426487191
##  169.71816891673856
##  225.52456481136363
##  289.81268449817225
##  361.78144542821906
##    ⋮
##    9.999700002251146e11
##    9.999740001693208e11
##    9.999780001218231e11
##    9.999820000810587e11
##    9.999860000495486e11
##    9.999900000250323e11
##    9.99994000009319e11
##    9.999980000017374e11
##    1.0000020000011713e12
```

---

class: inverse, center, middle

# 4. Scope

---

## Scope


The **scope** of a variable name determines when it is valid to refer to that variable
  - E.g.: if you create a variable inside a function, can you reference that variable outside the function?
  - You can think of scope as different contexts within your program

--
  
The two basic scopes are **local** and **global**

--

Scope can be a frustrating concept to grasp at first. But understanding how scopes work can save you a lot of debugging time

--

Let's walk through some simple examples to see how it works

---

## Scope

First, functions have their own **local scope**

--


```julia
ff(xx) = xx^2;
yy = 5;
ff(yy)
```

```
## 25
```

`xx` isn't bound to any values outside the function `ff`
- It is only used inside the function


---
## Scope

Locally scoped functions allow us to do things like:


```julia
xx = 10;
fff(xx) = xx^2;
fff(5)
```

```
## 25
```

--

Although `xx` was declared equal to 10 *outside the function*, the function still evaluated `xx` within its own scope at 5 (the value passed as argument)

---

## Scope

But, this type of scoping also has (initially) counterintuitive results like:


```julia
zz = 0;
for ii = 1:10
  zz = ii
end
println("zz = $zz")
```

```
## zz = 0
```

--

#### What happened?

---

## Scope

#### What happened?

The `zz` *outside* the for loop has a different scope: it's in the **global scope**

--

The global scope is the outermost scope, outside all functions and loops

--

The `zz` *inside* the for loop has a scope *local* to the loop

--

Since the outside `zz` has global scope, the locally scoped variables in the loop can't change it

---

## Scope

But hold on. If you copy and paste the previous code and run it in REPL, it will actually return 10, not 0. `\(^{*}\)` Was it all a lie?!

&lt;div align="center"&gt;
  &lt;img src="figures/scope_vscode.png"&gt;
&lt;/div&gt;

---

## Scope

Actually, there are two types of local scope: **soft** and **hard**

Here is how Julia `1.7` applies them

&lt;div align="center"&gt;
  &lt;img src="figures/scope_1.png"&gt;
&lt;/div&gt;

---

## Scope

When you assign `x = 10`

- If `x` is already defined in the local scope: the existing local `x` is assigned
--

- Otherwise
   - In **hard local scope**: a new local `x` is created and assigned
   - In **soft local scope**, it depends on whether a global `x` is defined...
--

      - If there is no global `x`: a new local `x` is created and assigned
      - If there is a global `x`: the assignment is *ambiguous*...
--
         - In *non-interactive* context (running a file): a new local `x` is created and assigned
         - In *interactive* context (REPL, notebooks): the global `x` is assigned
---

## Scope

So here is why we get different results:

- The `for` loop written in global (e.g.: outside of a function) has **soft local scope**

- When I run the code in a file to generate these slides, that `for` loop is in a *non-interactive* context `\(\rightarrow\)` a new local `zz` is created and assigned  

- When I run it in VS Code/REPL, it's in an *interactive* context `\(\rightarrow\)` the global `zz` is assigned  

--

(This is a bit confusing, I know...)

---


## Scope

Generally, you want to avoid global scope because it can cause conflicts, slowness, etc. But you can use `global` to force it if you want something to have global scope


```julia
zz = 0;
for ii = 1:10
  global zz
  zz = ii
end
println("zz = $zz")
```

```
## zz = 10
```

---

## Scope

Local scope kicks in whenever you have a new block keyword (i.e. you indented something) except for `if`

Global variables inside a local scope are inherited for .blue[reading], not writing


```julia
x, y = 1, 2;
function foo()
  x = 2        # assignment introduces a new local
  return x + y # y refers to the global
end;
foo()
```

```
## 4
```

```julia
x
```

```
## 1
```

---

## Scope

We can fix looping issues with global scope by using a wrapper function that doesn't do anything but change the parent scope so it is not global


```julia
zzz = 1;
function wrapper()
  zzz = 0;
  for iii = 1:10
    zzz = iii
  end
  println("zzz = $zzz")
end
```

```
## wrapper (generic function with 1 method)
```

```julia
wrapper()
```

```
## zzz = 10
```

---

class: inverse, center, middle

# 5. Generic programming

---

## Generic functions

If you use Julia to write code for research you should aim to write **generic functions**

--

These functions
- are flexible: e.g. can deal with someone using an `Int` instead of a `Float`
- have high performance, speed comparable to C

---

## Generic functions

Functions are made generic by paying attention to types and making sure types are **stable**

--

**Type stability:** Given an input into a function, operations on that input should maintain the type so Julia *knows* what its type will be throughout the full function call

--

This allows Julia to compile type-specialized versions of the functions, which will yield higher performance

--

*Type stability* sounds like mandating types (like what C and Fortran do, unlike what R and Python do). So how do we make it flexible?

---

## Generic functions: type stability

These two functions look the same, but are they?


```julia
function t1(n)
  s = 0
  t = 1
  for i in 1:n
     s += s/i
     t = div(t, i)
  end
  return t
end
```

```julia
function t2(n)
  s  = 0.0
  t = 1
  for i in 1:n
     s += s/i
     t = div(t, i)
  end
  return t
end
```

---

## Generic functions: type stability

No! t1 is *not type stable*

--

`t1` starts with `s` as an `Int64`. But then we have `s += s/i` which means it must hold a `Float64`

--

It must be converted to `Float` so it is not type stable

---

## Generic functions: type stability

We can see this when calling the macro `@code_warntype` where it reports `t1` at some point handles `s` that has type `Union{Float64,Int64}`, either `Float64` or `Int64`

Julia now can't assume `s`'s type and produce pure integer or floating point code. This leads to **performance degradation**

&lt;div align="center"&gt;
  &lt;img src="figures/t1_codewarn.png" height=200&gt;
  &lt;img src="figures/t2_codewarn.png" height=200&gt;
&lt;/div&gt;

---

## Concrete vs abstract types

A **concrete type** is one that can be instantiated 
- E.g.: `Float64`, `Bool`, `Int32`

--

An **abstract type** cannot 
- E.g.: `Real`, `Number`, `Any`

---

## Concrete vs abstract types

Abstract types are used for organizing types

You can check where types are in the hierarchy (with the subtype operator `&lt;:`)


```julia
@show Float64 &lt;: Real
```

```
## Float64 &lt;: Real = true
```

```
## true
```

```julia
@show Array &lt;: Real
```

```
## Array &lt;: Real = false
```

```
## false
```

---

## Concrete vs abstract types

You can see the type hierarchy with the supertypes and subtypes commands


```julia
using Base: show_supertypes
show_supertypes(Float64)
```

```
## Float64 &lt;: AbstractFloat &lt;: Real &lt;: Number &lt;: Any
```

---

## Creating new types

We can actually create new composite types using `struct`

--


```julia
struct FoobarNoType # This will be immutable by default
  a
  b
  c
end
```

This creates a new type called `FoobarNoType`

---

## Creating new types

We can generate a variable of type `FoobarNoType` using its **constructor** which will have the same name

--


```julia
newfoo = FoobarNoType(1.3, 2, "plzzz");
typeof(newfoo)
```

```
## FoobarNoType
```

```julia
newfoo.a
```

```
## 1.3
```

---

## Creating new types

Custom types are a *handy and elegant way of organizing your program*

- You can define a type `ModelParameters` to contain all your model parameters

- Each variable you instantiate represents a single scenario

- Then, instead of having a function call

```julia
RunMyModel(param1, param2, param3, param4, param5);
```

- You call

```julia
RunMyModel(modelParameters);
```


---

## Creating new types

.red[You should always declare types for the fields of a new composite type]

--

You can declare types with the double colon



```julia
struct FoobarType # This will be immutable by default
  a::Float64
  b::Int
  c::String
end
```

---

## Creating new types


```julia
newfoo_typed = FoobarType(1.3, 2, "plzzz");
typeof(newfoo_typed)
```

```
## FoobarType
```

```julia
newfoo.a
```

```
## 1.3
```

This lets the compiler generate efficient code because it knows the types of the fields when you construct a `FoobarType`

Declaring abstract types isn't good enough: you need to declare concrete types. But how do we keep it flexible, then?

---

## Creating new types

#### Parametric types are what help deliver flexibility

We can create types that hold different types of fields by declaring subsets of abstract types


```julia
struct FooParam{t1 &lt;: Real, t2 &lt;: Real, t3 &lt;: AbstractArray{&lt;:Real}}
  a::t1
  b::t2
  c::t3
end
newfoo_para = FooParam(1.0, 7, [1., 4., 6.])
```

```
## FooParam{Float64, Int64, Vector{Float64}}(1.0, 7, [1.0, 4.0, 6.0])
```

--

The curly brackets declare all the different type subsets we will use in `FooParam`

--

This actually delivers high-performance code!

---

class: inverse, center, middle

# 6. Multiple dispatch

---

## Multiple dispatch

#### Why type stability really matters: multiple dispatch

This means that the same function name can perform different operations depending on the type of the inputs it receives

In practice, a function specifies different **methods**, each of which operates on a specific set of types

---

## Multiple dispatch

When you write a function that is type stable, you are actually writing many different methods, each of which are optimized for certain types

--

If your function isn't type stable, the optimized method may not be used

This is why Julia can achieve C speed: it compiles optimized code for each type and doesn't need to waste time "guessing" a variable's type

---

## Multiple dispatch

`/` has MANY different methods for division depending on the input types! Each of these is a function specialized function that treats the inputs differently


```julia
methods(/)
```

```
## # 152 methods for generic function "/":
## [1] /(x::Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}, y::Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}) in Base at int.jl:97
## [2] /(x::T, y::T) where T&lt;:Union{Float16, Float32, Float64} in Base at float.jl:386
## [3] /(x::Union{Integer, Complex{&lt;:Union{Integer, Rational}}}, y::Rational) in Base at rational.jl:347
## [4] /(x::Union{Int16, Int32, Int8, UInt16, UInt32, UInt8}, y::BigInt) in Base.GMP at gmp.jl:547
## [5] /(c::Union{UInt16, UInt32, UInt8}, x::BigFloat) in Base.MPFR at mpfr.jl:441
## [6] /(c::Union{Int16, Int32, Int8}, x::BigFloat) in Base.MPFR at mpfr.jl:453
## [7] /(c::Union{Float16, Float32, Float64}, x::BigFloat) in Base.MPFR at mpfr.jl:465
## [8] /(U::Union{UnitUpperTriangular{var"#s886", S} where S&lt;:AbstractMatrix{var"#s886"}, UpperTriangular{var"#s886", S} where S&lt;:AbstractMatrix{var"#s886"}} where var"#s886"&lt;:Number, B::Bidiagonal{var"#s885", V} where {var"#s885"&lt;:Number, V&lt;:AbstractVector{var"#s885"}}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\bidiag.jl:880
## [9] /(U::Union{UnitUpperTriangular{T, S} where S&lt;:AbstractMatrix{T}, UpperTriangular{T, S} where S&lt;:AbstractMatrix{T}} where T, B::Bidiagonal) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\bidiag.jl:885
## [10] /(L::Union{LowerTriangular{var"#s886", S} where S&lt;:AbstractMatrix{var"#s886"}, UnitLowerTriangular{var"#s886", S} where S&lt;:AbstractMatrix{var"#s886"}} where var"#s886"&lt;:Number, B::Bidiagonal{var"#s885", V} where {var"#s885"&lt;:Number, V&lt;:AbstractVector{var"#s885"}}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\bidiag.jl:889
## [11] /(L::Union{LowerTriangular{T, S} where S&lt;:AbstractMatrix{T}, UnitLowerTriangular{T, S} where S&lt;:AbstractMatrix{T}} where T, B::Bidiagonal) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\bidiag.jl:894
## [12] /(X::StridedArray{P}, y::P) where P&lt;:Dates.Period in Dates at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\Dates\src\deprecated.jl:44
## [13] /(X::StridedArray{P}, y::Real) where P&lt;:Dates.Period in Dates at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\Dates\src\deprecated.jl:44
## [14] /(x::Union{SparseArrays.SparseVector{Tv, Ti}, SubArray{Tv, 1, &lt;:SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, false}, SubArray{Tv, 1, &lt;:SparseArrays.AbstractSparseVector{Tv, Ti}, Tuple{Base.Slice{Base.OneTo{Int64}}}, false}} where {Tv, Ti}, a::Number) in SparseArrays at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\SparseArrays\src\sparsevector.jl:1521
## [15] /(A::UnitUpperTriangular, x::Number) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:873
## [16] /(A::UnitUpperTriangular, B::UpperTriangular) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:1605
## [17] /(A::UnitUpperTriangular, B::UnitUpperTriangular) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:1617
## [18] /(A::UnitUpperTriangular, D::Diagonal) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\diagonal.jl:551
## [19] /(u::Adjoint{T, &lt;:AbstractVector} where T, A::Union{UnitLowerTriangular, UnitUpperTriangular}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:2667
## [20] /(u::Adjoint{T, &lt;:AbstractVector} where T, A::Union{LowerTriangular, UpperTriangular}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:2666
## [21] /(u::Adjoint{T, &lt;:AbstractVector} where T, D::Diagonal) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\diagonal.jl:756
## [22] /(A::Adjoint{T, &lt;:AbstractVector} where T, B::Transpose{&lt;:Any, &lt;:Bidiagonal}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\bidiag.jl:922
## [23] /(B::Adjoint{T, &lt;:AbstractVector} where T, F::Transpose{&lt;:Any, &lt;:Factorization{&lt;:Real}}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\factorization.jl:136
## [24] /(B::Adjoint{T, &lt;:AbstractVector} where T, F::Transpose{&lt;:Any, &lt;:Factorization}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\factorization.jl:138
## [25] /(u::Adjoint{T, &lt;:AbstractVector} where T, A::Transpose{&lt;:Any, &lt;:AbstractMatrix}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\adjtrans.jl:340
## [26] /(adjA::Adjoint{&lt;:Any, &lt;:AbstractMatrix}, F::Adjoint{&lt;:Any, &lt;:LU}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\lu.jl:445
## [27] /(adjA::Adjoint{&lt;:Any, &lt;:AbstractVector}, F::Adjoint{&lt;:Any, &lt;:LU}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\lu.jl:444
## [28] /(adjB::Adjoint{T, &lt;:AbstractVector} where T, adjF::Adjoint{&lt;:Any, &lt;:Factorization}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\factorization.jl:113
## [29] /(A::Adjoint{T, &lt;:AbstractVector} where T, B::Adjoint{&lt;:Any, &lt;:Bidiagonal}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\bidiag.jl:924
## [30] /(A::Adjoint{&lt;:Number, &lt;:AbstractVector}, B::Bidiagonal{var"#s885", V} where {var"#s885"&lt;:Number, V&lt;:AbstractVector{var"#s885"}}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\bidiag.jl:918
## [31] /(A::Adjoint{T, &lt;:AbstractVector} where T, B::Bidiagonal) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\bidiag.jl:920
## [32] /(u::Adjoint{T, &lt;:AbstractVector} where T, A::AbstractMatrix) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\adjtrans.jl:338
## [33] /(x::AbstractIrrational, y::AbstractIrrational) in Base at irrationals.jl:158
## [34] /(z::DualNumbers.Dual, w::DualNumbers.Dual) in DualNumbers at C:\Users\diego\.julia\packages\DualNumbers\5knFX\src\dual.jl:250
## [35] /(z::DualNumbers.Dual, x::Number) in DualNumbers at C:\Users\diego\.julia\packages\DualNumbers\5knFX\src\dual.jl:252
## [36] /(r::AbstractRange{&lt;:P}, x::P) where P&lt;:Dates.Period in Dates at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\Dates\src\ranges.jl:68
## [37] /(A::Hermitian, x::Real) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\symmetric.jl:609
## [38] /(x::Rational, y::Union{Integer, Complex{&lt;:Union{Integer, Rational}}, Rational}) in Base at rational.jl:346
## [39] /(x::Base.TwicePrecision, v::Number) in Base at twiceprecision.jl:326
## [40] /(x::Base.TwicePrecision, y::Base.TwicePrecision) in Base at twiceprecision.jl:330
## [41] /(A::UpperTriangular, x::Number) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:871
## [42] /(A::UpperTriangular, B::UpperTriangular) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:1599
## [43] /(A::UpperTriangular, B::UnitUpperTriangular) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:1611
## [44] /(A::UpperTriangular, D::Diagonal) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\diagonal.jl:550
## [45] /(A::Tridiagonal, B::Number) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\tridiag.jl:746
## [46] /(T::Tridiagonal, D::Diagonal) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\diagonal.jl:507
## [47] /(a::R, z::S) where {R&lt;:Real, S&lt;:Complex} in Base at complex.jl:345
## [48] /(x::Number, B::BitArray) in Base at bitarray.jl:1205
## [49] /(::Number, ::Missing) in Base at missing.jl:124
## [50] /(x::Number, v::AbstractVector) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\generic.jl:1146
## [51] /(z::Number, w::DualNumbers.Dual) in DualNumbers at C:\Users\diego\.julia\packages\DualNumbers\5knFX\src\dual.jl:251
## [52] /(x::ChainRulesCore.AbstractZero, ::ChainRulesCore.NotImplemented) in ChainRulesCore at C:\Users\diego\.julia\packages\ChainRulesCore\a4mIA\src\tangent_types\notimplemented.jl:47
## [53] /(a::ChainRulesCore.AbstractZero, ::ChainRulesCore.AbstractThunk) in ChainRulesCore at C:\Users\diego\.julia\packages\ChainRulesCore\a4mIA\src\tangent_types\thunks.jl:42
## [54] /(z::ChainRulesCore.AbstractZero, ::Any) in ChainRulesCore at C:\Users\diego\.julia\packages\ChainRulesCore\a4mIA\src\tangent_types\abstract_zero.jl:29
## [55] /(A::SymTridiagonal, B::Number) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\tridiag.jl:212
## [56] /(S::SymTridiagonal, D::Diagonal) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\diagonal.jl:500
## [57] /(x::RObject, y::RObject) in RCall at C:\Users\diego\.julia\packages\RCall\Wyd74\src\operators.jl:6
## [58] /(u::Transpose{T, &lt;:AbstractVector} where T, D::Diagonal) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\diagonal.jl:757
## [59] /(B::Transpose{T, &lt;:AbstractVector} where T, F::Transpose{&lt;:Any, &lt;:Factorization{&lt;:Real}}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\factorization.jl:137
## [60] /(B::AbstractMatrix, F::Transpose{&lt;:Any, &lt;:Factorization{&lt;:Real}}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\factorization.jl:134
## [61] /(B::Transpose{T, &lt;:AbstractVector} where T, F::Transpose{&lt;:Any, &lt;:Factorization}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\factorization.jl:139
## [62] /(B::AbstractMatrix, F::Transpose{&lt;:Any, &lt;:Factorization}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\factorization.jl:135
## [63] /(A::Transpose{T, &lt;:AbstractVector} where T, B::Transpose{&lt;:Any, &lt;:Bidiagonal}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\bidiag.jl:923
## [64] /(A::AbstractMatrix, B::Transpose{&lt;:Any, &lt;:Bidiagonal}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\bidiag.jl:915
## [65] /(trA::Transpose{&lt;:Any, &lt;:AbstractVector}, F::Adjoint{&lt;:Any, &lt;:LU}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\lu.jl:446
## [66] /(B::Transpose{T, &lt;:AbstractVector} where T, adjF::Adjoint{&lt;:Any, &lt;:Factorization}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\factorization.jl:114
## [67] /(trA::Transpose{&lt;:Any, &lt;:AbstractMatrix}, F::Adjoint{&lt;:Any, &lt;:LU}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\lu.jl:450
## [68] /(A::AbstractMatrix, F::Adjoint{&lt;:Any, &lt;:LU}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\lu.jl:439
## [69] /(A::Transpose{T, &lt;:AbstractVector} where T, B::Adjoint{&lt;:Any, &lt;:Bidiagonal}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\bidiag.jl:925
## [70] /(A::AbstractMatrix, B::Adjoint{&lt;:Any, &lt;:Bidiagonal}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\bidiag.jl:916
## [71] /(u::Transpose{T, &lt;:AbstractVector} where T, A::Adjoint{&lt;:Any, &lt;:AbstractMatrix}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\adjtrans.jl:341
## [72] /(u::Transpose{T, &lt;:AbstractVector} where T, A::LowerTriangular{&lt;:Any, &lt;:Transpose}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:2677
## [73] /(u::Transpose{T, &lt;:AbstractVector} where T, A::LowerTriangular{&lt;:Any, &lt;:Adjoint}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:2676
## [74] /(u::Transpose{T, &lt;:AbstractVector} where T, A::UnitLowerTriangular{&lt;:Any, &lt;:Transpose}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:2677
## [75] /(u::Transpose{T, &lt;:AbstractVector} where T, A::UnitLowerTriangular{&lt;:Any, &lt;:Adjoint}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:2676
## [76] /(u::Transpose{T, &lt;:AbstractVector} where T, A::UpperTriangular{&lt;:Any, &lt;:Transpose}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:2677
## [77] /(u::Transpose{T, &lt;:AbstractVector} where T, A::UpperTriangular{&lt;:Any, &lt;:Adjoint}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:2676
## [78] /(u::Transpose{T, &lt;:AbstractVector} where T, A::Union{LowerTriangular, UpperTriangular}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:2669
## [79] /(A::Transpose{&lt;:Number, &lt;:AbstractVector}, B::Bidiagonal{var"#s885", V} where {var"#s885"&lt;:Number, V&lt;:AbstractVector{var"#s885"}}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\bidiag.jl:919
## [80] /(A::Transpose{T, &lt;:AbstractVector} where T, B::Bidiagonal) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\bidiag.jl:921
## [81] /(u::Transpose{T, &lt;:AbstractVector} where T, A::UnitUpperTriangular{&lt;:Any, &lt;:Transpose}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:2677
## [82] /(u::Transpose{T, &lt;:AbstractVector} where T, A::UnitUpperTriangular{&lt;:Any, &lt;:Adjoint}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:2676
## [83] /(u::Transpose{T, &lt;:AbstractVector} where T, A::Union{UnitLowerTriangular, UnitUpperTriangular}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:2670
## [84] /(u::Transpose{T, &lt;:AbstractVector} where T, A::AbstractMatrix) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\adjtrans.jl:339
## [85] /(::ChainRulesCore.AbstractThunk, x::ChainRulesCore.NotImplemented) in ChainRulesCore at C:\Users\diego\.julia\packages\ChainRulesCore\a4mIA\src\tangent_types\notimplemented.jl:49
## [86] /(a::ChainRulesCore.AbstractThunk, b::ChainRulesCore.AbstractThunk) in ChainRulesCore at C:\Users\diego\.julia\packages\ChainRulesCore\a4mIA\src\tangent_types\thunks.jl:39
## [87] /(a::ChainRulesCore.AbstractThunk, b) in ChainRulesCore at C:\Users\diego\.julia\packages\ChainRulesCore\a4mIA\src\tangent_types\thunks.jl:37
## [88] /(A::Union{BitMatrix, BitVector}, B::Union{BitMatrix, BitVector}) in Base at bitarray.jl:1201
## [89] /(B::BitArray, x::Number) in Base at bitarray.jl:1204
## [90] /(A::Symmetric, x::Number) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\symmetric.jl:608
## [91] /(z::Complex, x::Real) in Base at complex.jl:346
## [92] /(A::LowerTriangular, x::Number) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:871
## [93] /(A::LowerTriangular, B::LowerTriangular) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:1575
## [94] /(A::LowerTriangular, B::UnitLowerTriangular) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:1587
## [95] /(A::LowerTriangular, D::Diagonal) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\diagonal.jl:550
## [96] /(J1::UniformScaling, J2::UniformScaling) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\uniformscaling.jl:266
## [97] /(J::UniformScaling, A::AbstractMatrix) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\uniformscaling.jl:267
## [98] /(J::UniformScaling, x::Number) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\uniformscaling.jl:272
## [99] /(x::P, y::P) where P&lt;:Dates.Period in Dates at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\Dates\src\periods.jl:80
## [100] /(x::P, y::Real) where P&lt;:Dates.Period in Dates at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\Dates\src\periods.jl:81
## [101] /(x::Dates.Period, y::Dates.Period) in Dates at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\Dates\src\periods.jl:99
## [102] /(H::UpperHessenberg, x::Number) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\hessenberg.jl:118
## [103] /(H::UpperHessenberg, x::UniformScaling) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\hessenberg.jl:118
## [104] /(A::AbstractMatrix, J::UniformScaling) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\uniformscaling.jl:269
## [105] /(v::AbstractVector, J::UniformScaling) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\uniformscaling.jl:270
## [106] /(H::UpperHessenberg, x::Diagonal) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\hessenberg.jl:118
## [107] /(H::UpperHessenberg, U::UpperTriangular) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\hessenberg.jl:136
## [108] /(H::UpperHessenberg, U::UnitUpperTriangular) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\hessenberg.jl:142
## [109] /(H::UpperHessenberg{var"#s886", S} where {var"#s886"&lt;:Number, S&lt;:AbstractMatrix{var"#s886"}}, B::Bidiagonal{var"#s885", V} where {var"#s885"&lt;:Number, V&lt;:AbstractVector{var"#s885"}}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\hessenberg.jl:174
## [110] /(H::UpperHessenberg, B::Bidiagonal) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\hessenberg.jl:173
## [111] /(A::UnitLowerTriangular, x::Number) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:873
## [112] /(A::UnitLowerTriangular, B::LowerTriangular) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:1581
## [113] /(A::UnitLowerTriangular, B::UnitLowerTriangular) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:1593
## [114] /(A::UnitLowerTriangular, D::Diagonal) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\diagonal.jl:551
## [115] /(r::StepRangeLen{&lt;:Real, &lt;:Base.TwicePrecision}, x::Real) in Base at twiceprecision.jl:555
## [116] /(A::Bidiagonal, B::Number) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\bidiag.jl:386
## [117] /(B::Bidiagonal{var"#s886", V} where {var"#s886"&lt;:Number, V&lt;:AbstractVector{var"#s886"}}, U::Union{UnitUpperTriangular{var"#s885", S} where S&lt;:AbstractMatrix{var"#s885"}, UpperTriangular{var"#s885", S} where S&lt;:AbstractMatrix{var"#s885"}} where var"#s885"&lt;:Number) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\bidiag.jl:898
## [118] /(B::Bidiagonal{var"#s886", V} where {var"#s886"&lt;:Number, V&lt;:AbstractVector{var"#s886"}}, L::Union{LowerTriangular{var"#s885", S} where S&lt;:AbstractMatrix{var"#s885"}, UnitLowerTriangular{var"#s885", S} where S&lt;:AbstractMatrix{var"#s885"}} where var"#s885"&lt;:Number) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\bidiag.jl:903
## [119] /(A::AbstractMatrix, B::Union{LowerTriangular, UpperTriangular}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:1662
## [120] /(A::AbstractMatrix, B::Union{UnitLowerTriangular, UnitUpperTriangular}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:1655
## [121] /(A::AbstractVector, B::Union{LowerTriangular, UpperTriangular}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:1662
## [122] /(A::AbstractVector, B::Union{UnitLowerTriangular, UnitUpperTriangular}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\triangular.jl:1655
## [123] /(B::Union{Array{Complex{T}, 1}, Array{Complex{T}, 2}}, F::Factorization{T}) where T&lt;:Union{Float32, Float64} in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\factorization.jl:96
## [124] /(B::AbstractMatrix, F::Union{Adjoint{&lt;:Any, &lt;:Factorization}, Factorization}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\factorization.jl:108
## [125] /(D::Diagonal, x::Number) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\diagonal.jl:204
## [126] /(A::AbstractArray, B::Number) in Base at arraymath.jl:24
## [127] /(A::Diagonal, D::Diagonal) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\diagonal.jl:444
## [128] /(A::AbstractVecOrMat, D::Diagonal) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\diagonal.jl:397
## [129] /(D::Diagonal{var"#s886", V} where {var"#s886"&lt;:Number, V&lt;:AbstractVector{var"#s886"}}, B::Bidiagonal{var"#s885", V} where {var"#s885"&lt;:Number, V&lt;:AbstractVector{var"#s885"}}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\bidiag.jl:909
## [130] /(A::AbstractMatrix{&lt;:Number}, B::Bidiagonal{var"#s885", V} where {var"#s885"&lt;:Number, V&lt;:AbstractVector{var"#s885"}}) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\bidiag.jl:872
## [131] /(A::AbstractMatrix, B::Bidiagonal) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\bidiag.jl:877
## [132] /(A::AbstractVecOrMat, B::AbstractVecOrMat) in LinearAlgebra at C:\Users\diego\AppData\Roaming\R\data\R\JULIAC~1\julia\18B0F0~1.5\JULIA-~1.5\share\julia\stdlib\v1.8\LinearAlgebra\src\generic.jl:1140
## [133] /(x::ChainRulesCore.NotImplemented, ::ChainRulesCore.AbstractThunk) in ChainRulesCore at C:\Users\diego\.julia\packages\ChainRulesCore\a4mIA\src\tangent_types\notimplemented.jl:48
## [134] /(a, b::ChainRulesCore.AbstractThunk) in ChainRulesCore at C:\Users\diego\.julia\packages\ChainRulesCore\a4mIA\src\tangent_types\thunks.jl:38
## [135] /(x::ChainRulesCore.NotImplemented, ::ChainRulesCore.NotImplemented) in ChainRulesCore at C:\Users\diego\.julia\packages\ChainRulesCore\a4mIA\src\tangent_types\notimplemented.jl:44
## [136] /(::Any, x::ChainRulesCore.NotImplemented) in ChainRulesCore at C:\Users\diego\.julia\packages\ChainRulesCore\a4mIA\src\tangent_types\notimplemented.jl:43
## [137] /(x::ChainRulesCore.NotImplemented, ::Any) in ChainRulesCore at C:\Users\diego\.julia\packages\ChainRulesCore\a4mIA\src\tangent_types\notimplemented.jl:42
## [138] /(x::BigFloat, c::Union{UInt16, UInt32, UInt8}) in Base.MPFR at mpfr.jl:436
## [139] /(x::BigFloat, c::Union{Int16, Int32, Int8}) in Base.MPFR at mpfr.jl:448
## [140] /(x::BigFloat, c::Union{Float16, Float32, Float64}) in Base.MPFR at mpfr.jl:460
## [141] /(x::BigFloat, y::BigFloat) in Base.MPFR at mpfr.jl:429
## [142] /(x::BigFloat, c::BigInt) in Base.MPFR at mpfr.jl:472
## [143] /(z::ComplexF64, w::ComplexF64) in Base at complex.jl:388
## [144] /(z::Complex{T}, w::Complex{T}) where T&lt;:Union{Float16, Float32} in Base at complex.jl:367
## [145] /(a::Complex{T}, b::Complex{T}) where T&lt;:Real in Base at complex.jl:348
## [146] /(x::BigInt, y::Union{Int16, Int32, Int8, UInt16, UInt32, UInt8}) in Base.GMP at gmp.jl:546
## [147] /(x::BigInt, y::BigInt) in Base.GMP at gmp.jl:497
## [148] /(x::T, y::T) where T&lt;:Integer in Base at int.jl:95
## [149] /(x::T, y::T) where T&lt;:Number in Base at promotion.jl:466
## [150] /(x::Number, y::Number) in Base at promotion.jl:391
## [151] /(::Missing, ::Number) in Base at missing.jl:123
## [152] /(::Missing, ::Missing) in Base at missing.jl:122
```

---

class: inverse, center, middle

# Programming advice

---

## Some concluding words on programming

There is really only one way to effectively get better at programming: **PRACTICE**

--

Yes, reading *can help*, especially by making you aware of tools and resources. But it's no substitute for actually solving problems with the computer


---

## Some concluding words on programming

#### How to get started with your practice? ####

My suggestion of an intuitive way: **practice writing programs to solve problems you would know how to solve by hand**

--

- The computer follows a strict logic that very often is different from yours
- Learning how to tell the computer to follow instructions and get to a destination you already know is a great way of learning

--

My personal favorite: [Project Euler](https://projecteuler.net) 

---

## Some concluding words on programming

&gt; *Project Euler is a series of challenging mathematical/computer programming problems that will require more than just mathematical insights to solve. Although mathematics will help you arrive at elegant and efficient methods, the use of a computer and programming skills will be required to solve most problems.*

--

Example of problems
1. If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. *Find the sum of all the multiples of 3 or 5 below 1000.*
--

2. The prime factors of 13195 are 5, 7, 13 and 29. *What is the largest prime factor of the number 600851475143 ?*

--

You can type in your answer and it will tell you if it's correct

---

## Some concluding words on programming

More on coding practices and efficiency:

- See [JuliaPraxis](https://github.com/JuliaPraxis) for best practices for naming, spacing, comments, etc

- See more [Performance tips](https://docs.julialang.org/en/v1/manual/performance-tips) from Julia Documentation


---

## What about ChatGPT?

- You are lucky! You're among the first cohort of people learning to program with an available AI language model that is advanced enough to **understand, explain, and generate** code

--

- There's actually a version exclusively for coding: CODEX

- Currently, one of the best available services for that is called GitHub Copilot. It's paid, but you can get it for free with an `.edu` email

**But hold on. Don't use this powerful resource without careful consideration**

---

## What about ChatGPT?

*But hold on. Don't use this powerful resource without careful consideration*

- **This must be a complement, not a substitute for your programming skills**

Why? 

--

- Professional software developers report GH Copilot produces buggy, incomplete, or outright incorrect code more often than not
  - Before you use it accurately, you need to be familiar enough with programming logic and the language you are using to know when things are wrong
- These tools will improve, but they will always be imperfect
  - There is an inherent limitation in translating ambiguous (natural) languages to non-ambiguous (formal) languages

---

## Advice on AI coding assistants

*Here is my personal advice to you focusing on your the medium/long-term career as a researcher*

1) **Do not use AI assistants to generate code you still cannot write and understand**

- There's too big of a risk of producing incorrect code
- It will place a low cap on your logical thinking for computational methods
- Once you advance and become familiar with programming structures, you start relying in AI to speed up your coding
  - Most likely, this will not happen much during this course

---

## Advice on AI coding assistants

*Here is my personal advice to you focusing on your the medium/long-term career as a researcher*

2) **Do use AI assistants to explain code to you**
- Throughout the semester, you will see many examples of algorithms
- AI can offer *tremendous* help explaining the inner workings of algorithms
  - [It can even do that as a 1940's gangster](https://twitter.com/HexenkingTV/status/1598278033336852483)

--

3) If you are a good programmer in one language, **AI tools can also help you translate code**
- Even in that case, I'd still recommend you start using it to explain code in the "new" language rather than simply generate code for you


---

## .blue[Course roadmap]

This concludes Unit 1. Up next

1. .gray[Intro to Scientific Computing]
2. **Numerical operations and representations** 
   1. **Numerical arithmetic** `\(\leftarrow\)`
   2. .gold[Numerical differentiation and integration]
3. Systems of equations
4. Function approximation
5. Optimization
6. Structural estimation

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
